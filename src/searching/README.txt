七大查找算法：参考文章：http://www.cnblogs.com/maybe2030/p/4715035.html#_labelTop
顺序查找：时间复杂度为O(n)
    顺序查找适合于存储结构为顺序存储或链接存储的线性表。
二分查找: 最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；
    二分查找的前提条件是元素必须是有序的
插值查找：查找成功或者失败的时间复杂度均为O(log2(log2n))。
    对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。
斐波那契查找:时间复杂度为O(log 2 n )
    需要额外开辟存储空间 用于补齐
    参考文档：https://blog.csdn.net/jinyan1111/article/details/79916455
树表查找：
    　　二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。
    平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。
    但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。
    红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。
    除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。


分块查找：
    分块查找又称索引顺序查找，它是顺序查找的一种改进方法。
    　　算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；
    即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；
    而第2块中任一元素又都必须小于第3块中的任一元素，……
    　　算法流程：
    step1 先选取各块中的最大关键字构成一个索引表；
    step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。


哈希查找
    单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。

        哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，
    那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。
