1、Java是如何实现多态的？
答：
多态的类型
https://blog.csdn.net/xiaoyu714543065/article/details/8130027
实现机制
https://blog.csdn.net/sinat_34311901/article/details/52208124

2、Java虚拟机的内存是如何划分的？
答：
https://www.cnblogs.com/whgk/p/6138522.html

3、Java的垃圾回收算法有哪些？垃圾收集器有哪些？不同的垃圾回收器有什么区别？
答：

3.1、判断对象已死的方法：
    A、引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用过他时，计数器加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不能再被使用的。
        缺点：很难解决对象之间相互循环引用的问题
    B、可达性分析算法：基本思路是通过一系列的称为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoot没有任何引用链相连，则证明此对象是不可用的。
        在Java语言中，可以作为GC Root的对象包括以下几种：
        a、虚拟机栈（栈帧中的本地变量表）中引用的对象
        b、方法区中静态属性引用的对象
        c、方法区中常量引用的对象
        d、本地方法栈中JIN（即一般说的Native方法）引用的对象
    即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，... ...
3.2、引用的概念：
    A、Java中引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。
    B、在JDK1.2之后，Java对引用的概念进行扩充，以下4种引用强度依次逐渐减弱：
        a、强引用：就是指在程序代码中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还在，垃圾收集器就永远不会回收掉被引用的对象。
        b、软引用：是用来描述一些还有用但并非必要的对象。
            对于软引用关联着的对象... ... 。在JDK1.2之后，提供了SoftReference类来实现软引用。
        c、弱引用：也是用来描述非必要对象的。被弱引用关联的对象只能存活到下一次垃圾回收之前。对应的实现类是WeakReference
        d、虚引用：也称为幽灵引用或者幻影引用。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知。对应的实现类是Phantom（幻影）Reference
3.3、回收方法区(以下称呼为永久代)：
    永久代的垃圾收集主要回收两部分内容：废弃的常量和无用的类
    A、判断一个常量是否为废弃的常量：与回收Java堆中的对象非常类似
    B、判断一个类是否为“无用的类”，要同时满足下面这三个条件：
        a、该类的所有实例都已经被回收，也就是Java堆中不存在该类的任何实例。
        b、加载该类的ClassLoader已经被回收
        c、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
    虚拟机可以对满足上述3个条件的无用类进行回收，仅仅是“可以”，并不是和对象一样，不使用了就必然会回收。
    在大量使用反射、动态代理、CGLib等ByteCode框架、动态代理生成JSP以及OSGi这类频繁自定义Class Loader的场景都需要虚拟机具备独立卸载的功能，以确保永久代不会溢出。
3.4、垃圾收集算法
    A、标记-清除算法(Mark-Sweep)：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
        主要有两点不足：
        a、一个是效率问题，标记和清除的两个过程的效率都不高；
        b、另一个是空间问题，标记清除之后会产生大量不连续的内存碎片。空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
    B、复制算法(Copying)(在新生代中使用)：将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了就将还存活的对象复制到另一块上面，然后再把已经使用过的内存空间一次性清理掉
        优缺点：实现简单、运行高效但是代价较大，将内存缩小了为原来的一半
        对该算法进行的优化：由于在实际生产中，新生代中的对象98%都是“朝生夕死”的，所以不需要1：1的比例来划分内存空间，
        而是将内存划分为一块较大的Eden(伊甸园)空间和两块较小的Survivor(幸存者)空间，每次使用Eden和其中一块Survivor。
        当回收时，将上述两块中还存活的对象一次性的复制到另外一个Survivor空间上面，然后对使用过的空进行进行一次性清理。Eden和Survivor的比例为8:1,这样只有10%的空间会浪费。
        当然98%的对象可回收只是一般情况下，如果回收之后有大于10%的对象存活，则需要依赖老年代的内存进行分配担保。
    C、标记-整理算法(Mark-Compact)(在老年代中使用):标记过程与标记-清除算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界之外的内存。
    D、分代收集算法(Generational Collection)：根据对象存活周期的不同将内存划分为几块。一般是将Java堆分为新生代和老年代，根据各自不同的特点选用适当的收集算法。

    E、可达性分析算法实现：
        a、通过OopMap的数据结构使虚拟机直接得知哪些地方存放着对象引用。
        b、安全点：程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停。
        c、如何让所有线程在发生GC时都能够跑到最近的安全点再停顿下来：
            抢先式中断：在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点。（现在几乎没有虚拟机采用这种方式）
            主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的。
            在这时还要考虑线程没有分配CPU时间的时候无法响应JVM的中断请求，走到安全点去中断挂起，这时需要使用安全区域来解决。
            安全区域是指：在一段代码片段之中，引用关系不会发生变化，在这个区域的任意地方开始GC都是安全的，也可以把SafeRegion看作是被扩展了的Safepoint。
3.5、垃圾收集器
    A、Serial收集器... ...

4、voliatile和synchonized有什么区别？synchonized和jdk提供的Lock包又有什么区别？
答：

5、Hash Map的原理是什么？在哪些情况下会出现线程安全问题？那么哪一个提供了线程安全的map？他的锁机制是如何实现的？
答：

6、常用的设计模式有哪些？
答：

7、Spring的AOP、IOC作用是什么？如何实现的？
答：


8、Java中的反射机制？
答：


其他知识点：
https://blog.csdn.net/so_sss/article/details/40120485

从硬件层面解释多线程  多CPU与多核CPU的区别：
https://blog.csdn.net/u012398362/article/details/51475213
